#!/usr/bin/env python3

import argparse
import copy
import os
import pathlib
import requests
import textwrap
import time

from cvelib.cve import checkSyntax, _getCVEPaths, CVE
from cvelib.common import (
    getConfigCveDataPaths,
    getConfigCompatUbuntu,
    error,
    rePatterns,
    updateProgress,
)

# TODO: pass these around
repos_all = []   # list of repos
issues_all = {}  # keys are repos, values are lists of issue urls
issues_ind = {}  # keys are 'repo/num', values are json docs


def _requestGetRaw(url, headers={}, params={}):
    """Wrapper around requests.get()"""
    hdrs = copy.deepcopy(headers)
    if len(hdrs) == 0:
        if "GHTOKEN" in os.environ:
            hdrs["Authorization"] = "token %s" % os.getenv("GHTOKEN")

    # print("DEBUG: url=%s, headers=%s, params=%s" % (url, hdrs, params))
    return requests.get(url, headers=hdrs, params=params)


def _requestGet(url, headers={}, params={}):
    """Wrapper around requests.get() for json"""
    r = _requestGetRaw(url, headers, params)
    if r.status_code >= 400:
        error("Problem fetching %s:\n%d - %s" % (url, r.status_code, r.json()))

    return r.json()


# https://docs.github.com/en/graphql/reference/objects#repositoryvulnerabilityalert
#
# GraphQL can be used on repos that have dependabot enabled. Oddly, there
# doesn't seem to be a way to see 'active' alerts. It seems that one would
# have to pull down the dependency graph (DependencyGraphDependency?) then
# see if anything in the RepositoryVulnerabilityAlerts are affected by looking
# at the versions....
#
# Eg:
# query = '''
# {
#   repository(name: "%s", owner: "%s") {
#     vulnerabilityAlerts(first: 100) {
#       nodes {
#         createdAt
#         dismissedAt
#         dismissReason
#         dismisser {
#           name
#         }
#         securityVulnerability {
#           package {
#             name
#           }
#           severity
#           advisory {
#             description
#           }
#         }
#         vulnerableManifestPath
#         securityAdvisory {
#           permalink
#         }
#       }
#     }
#   }
# }
# ''' % (repo, org)
def _queryGraphQL(query, headers={}):
    """Wrapper around requests.post() for graphql"""
    url = "https://api.github.com/graphql"
    hdrs = copy.deepcopy(headers)
    if len(hdrs) == 0:
        if "GHTOKEN" in os.environ:
            hdrs["Authorization"] = "token %s" % os.getenv("GHTOKEN")

    # TODO: handle rate limits:
    # https://docs.github.com/en/graphql/overview/resource-limitations
    r = requests.post(url, json={"query": query}, headers=hdrs)
    if r.status_code != 200:
        error("Problem querying %s. %d - %s" % (url, r.status_code, query))

    return r.json()


def _getGHReposAll(org):
    """Obtain the list of GitHub repos for the specified org"""
    global repos_all
    if len(repos_all) > 0:
        print("Using previously fetched list of repos")
        return copy.deepcopy(repos_all)

    url = "https://api.github.com/orgs/%s/repos" % org
    params = {"accept": "application/vnd.github.v3+json", "per_page": 100}

    print("Fetching list of repos: ", end="", flush=True)
    count = 0
    while True:
        count += 1
        print(".", end="", flush=True)
        params["page"] = count

        resj = _requestGet(url, params=params)
        if len(resj) == 0:
            print(" done!")
            break

        for repo in resj:
            if "name" in repo:
                repos_all.append(repo["name"])

    return copy.deepcopy(repos_all)


def _getGHIssuesForRepo(repo, org, labels=[], skip_labels=[]):
    """Obtain the list of GitHub issues for the specified repo and org"""
    global issues_all
    if repo in issues_all:
        print("Using previously fetched list of issues for %s" % repo)
        return sorted(copy.deepcopy(issues_all[repo]))

    url = "https://api.github.com/repos/%s/%s/issues" % (org, repo)
    params = {"accept": "application/vnd.github.v3+json", "per_page": 100}
    query_labels = [None]
    if len(labels) > 0:
        query_labels = labels

    print(" %s/%s: " % (org, repo), end="", flush=True)
    for query_label in query_labels:
        count = 0
        while True:
            count += 1
            print(".", end="", flush=True)
            params["page"] = count

            if query_label is not None:
                params["labels"] = query_label

            r = _requestGetRaw(url, params=params)
            if r.status_code == 410:  # repo turned off issues
                continue
            elif r.status_code >= 400:
                error("Problem fetching %s:\n%d - %s" % (url, r.status_code, r.json()))

            resj = r.json()
            if len(resj) == 0:
                break

            for issue in resj:
                # check if issue has any of the labels that we designated if
                # present, we should skip
                if len(skip_labels) > 0 and "labels" in issue:
                    found = False
                    for i in issue["labels"]:
                        if "name" in i and i["name"] in skip_labels:
                            found = True
                    if found:
                        continue

                if "pull_request" in issue and len(issue["pull_request"]) > 0:
                    continue  # skip pull requests
                if "html_url" in issue:
                    if repo not in issues_all:
                        issues_all[repo] = []
                    issues_all[repo].append(issue["html_url"])
    print(" done!")

    if repo in issues_all:
        return sorted(copy.deepcopy(issues_all[repo]))
    return []  # repo with turned off issues


def _getGHIssue(repo, org, number):
    """Obtain the GitHub issue for the specified repo, org and issue number"""
    global issues_ind
    k = "%s/%d" % (repo, number)
    if k in issues_ind:
        print("Using previously fetched issue for %s" % k)
        return issues_ind[k]

    url = "https://api.github.com/repos/%s/%s/issues/%d" % (org, repo, number)
    params = {"accept": "application/vnd.github.v3+json"}

    r = _requestGetRaw(url, params=params)
    if r.status_code == 410:  # repo turned off issues
        return {}
    elif r.status_code >= 400:
        error("Problem fetching %s:\n%d - %s" % (url, r.status_code, r.json()))

    issues_ind[k] = r.json()
    return issues_ind[k]


def _getKnownIssues(cves, filter_url=None):
    """Obtain the list of URLs in our CVE info"""

    def _collectable(url, filter):
        if rePatterns["github-issue"].match(url):
            if filter is None or "/%s/" % filter in url:
                return True
        return False

    urls = {}
    for cve in cves:
        for u in cve.references + cve.bugs:
            url = u.split()[0]
            if _collectable(url, filter_url):
                # strip off GH comments
                if url.startswith("https://github.com") and "#" in url:
                    url = url.split("#")[0]
                if url not in urls:
                    urls[url] = []
                if cve.candidate not in urls[url]:
                    urls[url].append(cve.candidate)

    return urls


def getMissingReport(cves, org, repos=[], labels=[], skip_labels=[]):
    """Compare list of issues in issue trackers against our CVE data"""
    known_urls = _getKnownIssues(cves, filter_url=org)

    fetch_repos = repos
    if len(fetch_repos) == 0:
        fetch_repos = _getGHReposAll(org)

    gh_urls = []
    print("Fetching list of issues for:")
    for repo in sorted(fetch_repos):
        for url in _getGHIssuesForRepo(repo, org, labels=labels, skip_labels=skip_labels):
            if url not in known_urls and url not in gh_urls:
                gh_urls.append(url)

    print("Issues missing from CVE data:")
    for url in gh_urls:
        print(" %s" % url)


def _getGHAlertsEnabled(org, repos=[]):
    fetch_repos = repos
    if len(fetch_repos) == 0:
        fetch_repos = _getGHReposAll(org)

    enabled = []
    disabled = []

    # Unfortunately there doesn't seem to be an API to tell us all the repos
    # with dependabot alerts, so get a list of URLs and then see if enabled or
    # not
    count = 0
    for repo in sorted(fetch_repos):
        count += 1
        updateProgress(count / len(fetch_repos), prefix="Collecting repo status: ")

        url = "https://api.github.com/repos/%s/%s/vulnerability-alerts" % (org, repo)
        params = {"accept": "application/vnd.github.v3+json"}

        res = _requestGetRaw(url, params=params)
        if res.status_code == 204:
            # enabled
            enabled.append(repo)
        elif res.status_code == 404:
            # disabled
            disabled.append(repo)
        else:
            error("Problem fetching %s:\n%d - %s" % (url, res.status_code, res))

    return enabled, disabled


def getGHAlertsStatusReport(cves, org, repos=[]):
    """Obtain list of repos that have vulnerability alerts enabled/disabled"""
    enabled, disabled = _getGHAlertsEnabled(org, repos)
    print("Enabled:\n%s" % "\n".join(" %s" % r for r in enabled))
    print("Disabled:\n%s" % "\n".join(" %s" % r for r in disabled))


def getUpdatedReport(cves, org, since=0):
    """Obtain list of URLs that have received an update since last run"""
    urls = _getKnownIssues(cves, filter_url=org)

    # convert since to a date string that we can lexigraphically compare to the
    # github string
    if not isinstance(since, int) or since < 0:
        raise ValueError
    since_str = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(since))

    # find updates
    updated_urls = []
    count = 0
    for url in sorted(urls.keys()):
        count += 1
        updateProgress(count / len(urls), prefix="Collecting known issues: ")

        # TODO: break this out
        if not rePatterns["github-issue"].match(url):
            continue  # only support github issues at this time
        tmp = url.split("/")

        # compare the issue's updated_at with our since time
        issue = _getGHIssue(tmp[4], tmp[3], int(tmp[6]))
        if "updated_at" in issue and issue["updated_at"] > since_str:
            updated_urls.append(url)

    print("Updated issues:")
    for url in updated_urls:
        print(" %s (%s)" % (url, ", ".join(urls[url])))


def _printGHAlertsUpdatedSummary(org, repo, alert):
    """Print out the alert summary"""
    url = "https://github.com/%s/%s/security/dependabot" % (org, repo)
    print("%s alerts: %d (%s)" % (repo, len(alert), url))

    # for n in alert:
    for n in sorted(alert, key=lambda i: (i["pkg"], i["created"])):
        print("  %s" % n["pkg"])
        print("    - severity: %s" % n["severity"])
        print("    - created: %s" % n["created"])
        print("    - %s" % n["path"])
        print("    - %s" % n["ghsa"])
        print("")


def _printGHAlertsUpdatedTemplates(org, repo, alert):
    """Print out the updated alerts issue templates"""
    sev = ["unknown", "low", "moderate", "high", "critical"]
    highest = 0

    items = {}
    for n in alert:
        s = "- [ ] %s (%s)" % (n["pkg"], n["severity"])
        if s not in items:
            items[s] = 1
        else:
            items[s] += 1
        try:
            cur = sev.index(n["severity"])
        except ValueError:
            cur = sev.index("unknown")

        if cur > highest:
            highest = cur

    checklist = ""
    for i in sorted(items.keys()):
        if items[i] > 1:
            checklist += "%s\n" % (i.replace("(", "(%d " % (items[i])))
        else:
            checklist += "%s\n" % i

    priority = sev[highest]
    if priority == "moderate" or priority == "unknown":
        priority = "medium"

    print("# %s template" % repo)
    url = "https://github.com/%s/%s/security/dependabot" % (org, repo)
    template = """Please update dependabot flagged [Go|node|...] dependencies in %s

%s lists updates for [Go|node|elixir|...]:
%s
Since a '%s' severity issue is present, tentatively adding the 'security/%s' label. At the time of filing, the above is untriaged. When updating the above checklist, please add supporting github comments as triaged, not affected or remediated. Dependabot only reported against the default branch so please be sure to check any other supported branches when researching/fixing.

Thanks!""" % (
        repo,
        url,
        checklist,
        sev[highest],
        priority,
    )

    print(template)
    print("# end template")


def getGHAlertsUpdatedReport(cves, org, since=0, repos=[], with_templates=False):
    """Obtain list of URLs that have received a vulnerability update since last run"""
    enabled, disabled = _getGHAlertsEnabled(org, repos)

    # convert since to a date string that we can lexigraphically compare to the
    # github string
    if not isinstance(since, int) or since < 0:
        raise ValueError
    since_str = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(since))

    # find updates
    updated = {}
    count = 0
    # for large numbers of 'enabled', we might get rate limited:
    # https://docs.github.com/en/graphql/overview/resource-limitations
    for repo in sorted(enabled):
        count += 1
        updateProgress(count / len(enabled), prefix="Collecting alerts: ")

        cursorAfter = ""
        while True:
            query = """
    {
      repository(name: "%s", owner: "%s") {
        vulnerabilityAlerts(first: 100%s) {
          nodes {
            createdAt
            securityVulnerability {
              package {
                name
              }
              severity
            }
            vulnerableManifestPath
            securityAdvisory {
              permalink
            }
          }
          pageInfo {
            startCursor
            endCursor
            hasNextPage
          }
        }
      }
    }
    """ % (
                repo,
                org,
                cursorAfter,
            )
            res = _queryGraphQL(query)
            # import json
            # print(json.dumps(res, indent=2))
            for n in res["data"]["repository"]["vulnerabilityAlerts"]["nodes"]:
                if n["createdAt"] > since_str:
                    if repo not in updated:
                        updated[repo] = []

                    updated[repo].append(
                        {
                            "pkg": n["securityVulnerability"]["package"]["name"],
                            "severity": n["securityVulnerability"]["severity"].lower(),
                            "path": n["vulnerableManifestPath"],
                            "ghsa": n["securityAdvisory"]["permalink"],
                            "created": n["createdAt"],
                        }
                    )

            # deal with pagination
            if not res["data"]["repository"]["vulnerabilityAlerts"]["pageInfo"][
                "hasNextPage"
            ]:
                break
            cursorAfter = (
                ', after: "%s"'
                % res["data"]["repository"]["vulnerabilityAlerts"]["pageInfo"][
                    "endCursor"
                ]
            )

    if len(updated) == 0:
        print("No vulnerability alerts")
        return

    print("Vulnerability alerts:")
    for repo in sorted(updated.keys()):
        if with_templates:
            _printGHAlertsUpdatedTemplates(org, repo, updated[repo])
            print("")
        _printGHAlertsUpdatedSummary(org, repo, updated[repo])


def main():
    parser = argparse.ArgumentParser(
        prog="cve-report-updated-bugs",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Generate reports on security issue bug updates",
        epilog=textwrap.dedent(
            """\
Example usage:

  # first export a GitHub Personal Access Token that can read issues:
  $  export GHTOKEN=...

  # Show issues that are referenced in open CVE data that have been
  # updated since last week
  $ cve-report-updated-bugs --show-updated \\
      --gh-org foo --since $(date --date "7 days ago" "+%s")

  # Show list of issues for specific repos in an org with different
  # labels
  $ cve-report-updated-bugs --show-missing \\
      --gh-org foo \\
      --gh-labels="bar:baz" \\
      --gh-repos=norg,corge,qux

  # Show GitHub dependabot alerts since last stamp file
  $ cve-report-updated-bugs --gh-show-alerts \\
      --gh-org foo \\
      --since-stamp /path/to/stamp
        """
        ),
    )
    parser.add_argument(
        "--show-combined",
        dest="show_combined",
        help="show dependabot, missing and updates",
        action="store_true",
    )
    parser.add_argument(
        "--show-missing",
        dest="show_missing",
        help="show URLs missing from CVE info",
        action="store_true",
    )
    parser.add_argument(
        "--show-updated",
        dest="show_updated",
        help="show URLs that have been updated since --since TIME",
        action="store_true",
    )
    parser.add_argument(
        "--gh-org",
        dest="gh_org",
        type=str,
        help="GitHub URLs must belong to ORG",
        default=None,
    )
    parser.add_argument(
        "--gh-repos",
        dest="gh_repos",
        type=str,
        help="Comma-separated list of GitHub repos",
        default=None,
    )
    # The GitHub API uses:
    #   &labels=foo     - issue has 'foo' label
    #   &labels=bar,baz - issue has 'bar' and 'baz' labels
    #
    # --gh-labels uses ',' for AND and ':' for OR such that
    #   foo             - show issues with 'foo' label
    #   foo:bar         - show issues with 'foo' or 'bar' label
    #   foo:bar,baz     - show issues with 'foo' label or 'bar' and 'baz labels
    parser.add_argument(
        "--gh-labels",
        dest="gh_labels",
        type=str,
        help="Colon-separated list of GitHub labels (use commans for ANDed labels)",
        default=None,
    )
    # Consider that --gh-labels=foo returns all issues with the label 'foo'.
    # Sometimes it is useful to list all issues with the label foo but without
    # label 'bar'. Use --gh-labels=foo --gh-skip-labels=bar
    parser.add_argument(
        "--gh-skip-labels",
        dest="gh_skip_labels",
        type=str,
        help="Colon-separated list of GitHub labels to skip issues when present",
        default=None,
    )
    parser.add_argument(
        "--gh-show-alerts-repo-status",
        dest="gh_show_alerts_repo_status",
        help="show status of GitHub vulnerability alerts (dependabot) by repo",
        action="store_true",
    )
    parser.add_argument(
        "--gh-show-alerts",
        dest="gh_show_alerts",
        help="show GitHub vulnerability alerts (dependabot)",
        action="store_true",
    )
    parser.add_argument(
        "--gh-show-alerts-templates",
        dest="gh_show_alerts_templates",
        help="show GitHub vulnerability alerts (dependabot)",
        action="store_true",
    )
    parser.add_argument(
        "--since",
        dest="since",
        type=int,
        help="Report bug updates since TIME (in epoch seconds)",
        default=0,
    )
    parser.add_argument(
        "--since-stamp",
        dest="since_stamp",
        type=str,
        help="Report bug updates since last TIME based on stamp file",
        default=None,
    )

    args = parser.parse_args()

    if args.show_combined:
        args.show_updated = True
        args.show_missing = True
        args.gh_show_alerts = True

    if (
        not args.show_missing
        and not args.show_updated
        and not args.gh_show_alerts
        and not args.gh_show_alerts_repo_status
    ):
        error(
            "Please specify one of --show-missing, --show-updated, --gh-show-alerts or --gh-show-alerts-repo-status"
        )
    elif (args.show_updated or args.gh_show_alerts) and (
        args.since == 0 and args.since_stamp is None
    ):
        error(
            "Please specify --since and/or --since-stamp with --show-updated/--gh-show-alerts"
        )
    elif args.gh_show_alerts_templates and not args.gh_show_alerts:
        error("Please specify --gh-show-alerts with --gh-show-alerts-templates")

    if "GHTOKEN" not in os.environ:
        error("Please export GitHub personal access token as GHTOKEN")

    cveDirs = getConfigCveDataPaths()
    compat = getConfigCompatUbuntu()

    # First, check the syntax of our CVEs
    checkSyntax(cveDirs, compat, untriagedOk=True)

    # Gather the CVEs (including retired/ and ignored/)
    cves = []
    for cve_fn in _getCVEPaths(cveDirs):
        cves.append(CVE(fn=cve_fn, compatUbuntu=compat, untriagedOk=True))

    if args.show_updated or args.gh_show_alerts:
        # Allow for specifying --since and --since-stamp together. Eg:
        #   --since alone just sets 'since' with no stamp file
        #   --since-stamp alone where stamp file doesn't exists defaults to '0'
        #     then creates the stamp file
        #   --since-stamp alone where stamp file exists uses mtime of stamp
        #     file then updates the stamp file
        #   --since with --since-stamp sets 'since' to --since and then updates
        #     stamp file
        since = args.since
        if (
            args.since == 0
            and args.since_stamp is not None
            and os.path.exists(args.since_stamp)
        ):
            since = int(os.path.getmtime(args.since_stamp))

        if args.gh_show_alerts:
            if args.show_combined:
                print("# Alerts")
            repos = []
            if args.gh_repos is not None:
                repos = args.gh_repos.split(",")
            getGHAlertsUpdatedReport(
                cves,
                args.gh_org,
                since=since,
                repos=repos,
                with_templates=args.gh_show_alerts_templates,
            )

        if args.show_updated:
            if args.show_combined:
                print("# Updates")
            getUpdatedReport(cves, args.gh_org, since=since)

        if args.since_stamp is not None:
            pathlib.Path(args.since_stamp).touch()

    if args.show_missing:
        if args.show_combined:
            print("# Missing")
        repos = []
        if args.gh_repos is not None:
            repos = args.gh_repos.split(",")
        labels = []
        if args.gh_labels is not None:
            labels = args.gh_labels.split(":")
        skip_labels = []
        if args.gh_skip_labels is not None:
            skip_labels = args.gh_skip_labels.split(":")
        getMissingReport(cves, args.gh_org, repos=repos, labels=labels, skip_labels=skip_labels)

    if args.gh_show_alerts_repo_status:
        repos = []
        if args.gh_repos is not None:
            repos = args.gh_repos.split(",")
        getGHAlertsStatusReport(cves, args.gh_org, repos=repos)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        error("Aborted.")
