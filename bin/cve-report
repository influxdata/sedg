#!/usr/bin/env python3

import argparse
import sys
import time

from cvelib.cve import checkSyntax, _getCVEPaths, CVE
from cvelib.common import (
    cve_priorities,
    getConfigCveDataPaths,
    getConfigCompatUbuntu,
)


def _readStatsUniqueCVEs(cves, filter_status=["needs-triage", "needed", "pending"]):
    stats = {}
    for cve in cves:
        last_software = ""
        for pkg in cve.pkgs:
            if pkg.status not in filter_status:
                continue

            # only count an open CVE once per software/priority
            if last_software == pkg.software:
                continue
            last_software = pkg.software

            priority = cve.priority
            if pkg.software in pkg.priorities:
                priority = pkg.priorities[pkg.software]

            if pkg.software not in stats:
                stats[pkg.software] = {}
                for pri in cve_priorities:
                    stats[pkg.software][pri] = {}
                    stats[pkg.software][pri]["num"] = 0

            stats[pkg.software][priority]["num"] += 1
            if "cves" not in stats[pkg.software][priority]:
                stats[pkg.software][priority]["cves"] = []
            stats[pkg.software][priority]["cves"].append(cve.candidate)

    return stats


def getHumanReportOpenByPkgPriority(stats):
    print("{pkg:20} {critical:>10s} {high:>10s} {medium:>10s} {low:>10s} {negligible:>10s}".format(
        pkg="Package",
        critical="Critical",
        high="High",
        medium="Medium",
        low="Low",
        negligible="Negligible")
    )

    table_f = "{pkg:20s} {critical:>10d} {high:>10d} {medium:>10d} {low:>10d} {negligible:>10d}".format
    totals = {}
    for pri in cve_priorities:
        totals[pri] = 0

    for p in sorted(stats):
        print(table_f(
            pkg=p,
            critical=stats[p]['critical']["num"],
            high=stats[p]['high']["num"],
            medium=stats[p]['medium']["num"],
            low=stats[p]['low']["num"],
            negligible=stats[p]['negligible']["num"],)
        )
        for pri in cve_priorities:
            totals[pri] += stats[p][pri]["num"]

    print(table_f(
        pkg="Total:",
        critical=totals['critical'],
        high=totals['high'],
        medium=totals['medium'],
        low=totals['low'],
        negligible=totals['negligible'],)
    )


def getHumanReport(cves):
    stats_open = _readStatsUniqueCVEs(cves)
    print("# Unique open issues by software")
    getHumanReportOpenByPkgPriority(stats_open)

    print("\n# Unique closed issues by software")
    stats_closed = _readStatsUniqueCVEs(cves, filter_status=["released"])
    getHumanReportOpenByPkgPriority(stats_closed)


def getHumanTodo(cves):
    stats_open = _readStatsUniqueCVEs(cves)
    points = {
        "critical": 200,
        "high": 100,
        "medium": 50,
        "low": 10,
        "negligible": 0,
    }

    scores = {}
    for sw in stats_open.keys():
        score = 0
        scores[sw] = {}

        s = ""
        for p in cve_priorities:
            score += stats_open[sw][p]["num"] * points[p]
            if stats_open[sw][p]["num"] > 0:
                s += "%d %s, " % (stats_open[sw][p]["num"], p)
        scores[sw]["score"] = score
        scores[sw]["msg"] = "%s: %s" % (sw, s[:-2])

    # descending sorted by score then ascending by key ('sw')
    for (k, v) in sorted(scores.items(), key=lambda k: (-k[1]["score"], k)):
        print("%-8d %s" % (v["score"], v["msg"]))


def getHumanSoftwareInfo(cves, pkg=""):
    stats_open = _readStatsUniqueCVEs(cves)

    for sw in stats_open.keys():
        if pkg != "" and sw != pkg:
            continue
        print("%s:" % sw)
        for p in cve_priorities:
            if stats_open[sw][p]["num"] > 0:
                print("  %s:" % p)
                for cve in sorted(stats_open[sw][p]["cves"]):
                    print("    %s" % cve)


# line protocol
# We plan to query on priority, status and product so put them as tags
#
#   <measurement>,priority=X,status=X,product=X,modifier=X id=X software=X
#
# Note: the concept of 'team' will be handled within the flux
def _readStatsLineProtocol(cves, measurement="cveLog", filter_status=["needs-triage", "needed", "pending"], base_timestamp=None):
    stats = []
    lp_f = '{measurement},priority={priority},status={status},product={product} id="{id}",software="{software}",modifier="{modifier}" {timestamp}'.format

    base_tm = None
    if base_timestamp is not None:
        if not isinstance(base_timestamp, int) or base_timestamp < 0:
            raise ValueError
        base_tm = int(time.mktime(time.gmtime(base_timestamp))) * 1000 * 1000 * 1000

    # XXX: perhaps use a timestamp relative to the mtime of the file or git
    # commit (that would rotate out though with retention policy)
    for cve in cves:
        for pkg in cve.pkgs:
            priority = cve.priority
            if pkg.software in pkg.priorities:
                priority = pkg.priorities[pkg.software]

            if pkg.status not in filter_status:
                continue

            if base_tm is None:
                timestamp = int(time.time_ns())
            else:
                timestamp = base_tm
                base_tm += 1

            stats.append(lp_f(
                measurement=measurement,
                priority=priority,
                status=pkg.status,
                product=pkg.product,
                id=cve.candidate,
                software=pkg.software,
                modifier=pkg.modifier,
                timestamp=timestamp,
            ))

    return stats


def getInfluxDBLineProtocol(cves, base_timestamp=None):
    stats_open = _readStatsLineProtocol(cves, base_timestamp=base_timestamp)
    for s in stats_open:
        print(s)


def main():
    parser = argparse.ArgumentParser(
        prog="cve-report",
        description="Generate reports on security issues",
    )
    parser.add_argument(
        "--output-sw",
        dest="output_sw",
        help="output software info in human-readable form",
        type=str,
        nargs='?',
        const="",
    )
    parser.add_argument(
        "--output-todolist",
        dest="output_todolist",
        help="output todo list in human-readable form",
        action="store_true",
    )
    parser.add_argument(
        "--output-influxdb",
        dest="output_influxdb",
        help="output InfluxDB line protocol",
        action="store_true",
    )
    parser.add_argument(
        "--output-influxdb-starttime",
        dest="output_influxdb_starttime",
        type=int,
        help="Use TIME as base start time for InfluxDB line protocol",
        default=None,
    )
    args = parser.parse_args()

    cveDirs = getConfigCveDataPaths()
    compat = getConfigCompatUbuntu()

    # First, check the syntax of our CVEs
    checkSyntax(cveDirs, compat, untriagedOk=True)

    # Gather the CVEs
    cves = []
    for cve_fn in _getCVEPaths(cveDirs):
        cves.append(CVE(fn=cve_fn, compatUbuntu=compat, untriagedOk=True))

    # send to a report
    if args.output_influxdb:
        getInfluxDBLineProtocol(cves, args.output_influxdb_starttime)
    elif args.output_todolist:
        getHumanTodo(cves)
    elif args.output_sw is not None:
        getHumanSoftwareInfo(cves, args.output_sw)
    else:
        getHumanReport(cves)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Aborted.")
        sys.exit(1)
