#!/usr/bin/env python3

import argparse
import os
import sys
import textwrap
import time

from cvelib.cve import checkSyntax, _getCVEPaths, CVE
from cvelib.common import (
    cve_priorities,
    error,
    getConfigCveDataPaths,
    getConfigCompatUbuntu,
)


def _readStatsUniqueCVEs(cves, filter_status=["needs-triage", "needed", "pending"]):
    stats = {}
    for cve in cves:
        last_software = ""
        for pkg in cve.pkgs:
            if pkg.status not in filter_status:
                continue

            # only count an open CVE once per software/priority
            if last_software == pkg.software:
                continue
            last_software = pkg.software

            priority = cve.priority
            if pkg.software in pkg.priorities:
                priority = pkg.priorities[pkg.software]

            if pkg.software not in stats:
                stats[pkg.software] = {}
                stats[pkg.software]["deps"] = []
                for pri in cve_priorities:
                    stats[pkg.software][pri] = {}
                    stats[pkg.software][pri]["num"] = 0

            stats[pkg.software][priority]["num"] += 1
            if "cves" not in stats[pkg.software][priority]:
                stats[pkg.software][priority]["cves"] = []
            stats[pkg.software][priority]["cves"].append(cve.candidate)

            if "dependabot" in cve.discoveredBy.lower() and \
                    cve.candidate not in stats[pkg.software]["deps"]:
                stats[pkg.software]["deps"].append(cve.candidate)

    return stats


def getHumanReportOpenByPkgPriority(stats):
    maxlen = 30
    headerStr = (
        "{pkg:%d} {critical:>10s} {high:>10s} {medium:>10s} {low:>10s} {negligible:>10s}"
        % maxlen
    )
    print(
        headerStr.format(
            pkg="Package",
            critical="Critical",
            high="High",
            medium="Medium",
            low="Low",
            negligible="Negligible",
        )
    )

    tableStr = (
        "{pkg:%ds} {critical:>10d} {high:>10d} {medium:>10d} {low:>10d} {negligible:>10d}"
        % maxlen
    )
    table_f = tableStr.format
    totals = {}
    for pri in cve_priorities:
        totals[pri] = 0

    for p in sorted(stats):
        print(
            table_f(
                pkg=(p[: maxlen - 3] + "...") if len(p) > maxlen else p,
                critical=stats[p]["critical"]["num"],
                high=stats[p]["high"]["num"],
                medium=stats[p]["medium"]["num"],
                low=stats[p]["low"]["num"],
                negligible=stats[p]["negligible"]["num"],
            )
        )
        for pri in cve_priorities:
            totals[pri] += stats[p][pri]["num"]

    print(
        table_f(
            pkg="Total:",
            critical=totals["critical"],
            high=totals["high"],
            medium=totals["medium"],
            low=totals["low"],
            negligible=totals["negligible"],
        )
    )


def getHumanReport(cves):
    stats_open = _readStatsUniqueCVEs(cves)
    print("# Unique open issues by software")
    getHumanReportOpenByPkgPriority(stats_open)

    print("\n# Unique closed issues by software")
    stats_closed = _readStatsUniqueCVEs(cves, filter_status=["released"])
    getHumanReportOpenByPkgPriority(stats_closed)


def getHumanTodo(cves):
    stats_open = _readStatsUniqueCVEs(cves)
    points = {
        "critical": 200,
        "high": 100,
        "medium": 50,
        "low": 10,
        "negligible": 0,
    }

    scores = {}
    for sw in stats_open.keys():
        score = 0
        scores[sw] = {}

        s = ""
        for p in cve_priorities:
            score += stats_open[sw][p]["num"] * points[p]
            if stats_open[sw][p]["num"] > 0:
                s += "%d %s, " % (stats_open[sw][p]["num"], p)
        scores[sw]["score"] = score
        scores[sw]["msg"] = "%s: %s" % (sw, s[:-2])

    # descending sorted by score then ascending by key ('sw')
    for (k, v) in sorted(scores.items(), key=lambda k: (-k[1]["score"], k)):
        print("%-8d %s" % (v["score"], v["msg"]))


def getHumanSoftwareInfo(cves, pkg=""):
    stats_open = _readStatsUniqueCVEs(cves)

    for sw in sorted(stats_open.keys()):
        if pkg != "" and sw != pkg:
            continue
        print("%s:" % sw)
        for p in cve_priorities:
            if stats_open[sw][p]["num"] > 0:
                print("  %s:" % p)
                for cve in sorted(stats_open[sw][p]["cves"]):
                    print("    %s" % cve)


def _readPackagesFile(pkg_fn):
    pkgs = None
    if pkg_fn:
        if not os.path.isfile(pkg_fn):
            error("'%s' is not a regular file" % pkg_fn)
        with open(pkg_fn, "r") as fh:
            pkgs = set(fh.read().splitlines())

    return pkgs


def getHumanSummary(cves, pkg_fn=""):
    def _output(stats, state, pkgs):
        maxlen = 30
        tableStr = "{pri:10s} {repo:%ds} {cve:25s} {dep:s}" % maxlen
        table_f = tableStr.format

        lines_open = {}
        totals = {
            "critical": {"num": 0, "num_repos": 0},
            "high": {"num": 0, "num_repos": 0},
            "medium": {"num": 0, "num_repos": 0},
            "low": {"num": 0, "num_repos": 0},
            "negligible": {"num": 0, "num_repos": 0},
        }
        for repo in sorted(stats):
            # skip repos not in the list we want to report on
            if pkgs is not None and repo not in pkgs:
                continue

            for priority in stats[repo]:
                if priority == "deps":
                    continue

                if stats[repo][priority]["num"] > 0:
                    if priority not in lines_open:
                        lines_open[priority] = {}
                    lines_open[priority][repo] = stats[repo][priority]["cves"]

                    if priority not in totals:
                        totals[priority] = {"num": 0, "num_repos": 0}
                    totals[priority]["num"] += len(stats[repo][priority]["cves"])
                    totals[priority]["num_repos"] += 1

        print("# %s\n" % state.capitalize())
        print(table_f(pri="Priority", repo="Repository", cve="Issue", dep=""))
        print(table_f(pri="--------", repo="----------", cve="-----", dep=""))
        for priority in ["critical", "high", "medium", "low", "negligible"]:
            if priority not in lines_open:
                continue
            for repo in sorted(lines_open[priority]):
                for cve in sorted(lines_open[priority][repo]):
                    # print("%s\t%s\t%s" % (priority, repo, cve))
                    print(
                        table_f(
                            pri=priority,
                            repo=(repo[: maxlen - 3] + "...")
                            if len(repo) > maxlen
                            else repo,
                            cve=cve,
                            dep="(dependabot)" if cve in stats[repo]["deps"] else "",
                        )
                    )

        print("\nTotals:")
        for priority in ["critical", "high", "medium", "low", "negligible"]:
            print(
                "- %s: %d in %d repos"
                % (priority, totals[priority]["num"], totals[priority]["num_repos"])
            )

    pkgs = _readPackagesFile(pkg_fn)

    stats_open = _readStatsUniqueCVEs(cves)
    _output(stats_open, "open", pkgs)

    print("\n")
    stats_closed = _readStatsUniqueCVEs(cves, filter_status=["released"])
    _output(stats_closed, "closed", pkgs)


# line protocol
# We plan to query on priority, status and product so put them as tags
#
#   <measurement>,priority=X,status=X,product=X,modifier=X id=X software=X
#
# Note: the concept of 'team' will be handled within the flux
def _readStatsLineProtocol(
    cves,
    measurement="cveLog",
    filter_status=["needs-triage", "needed", "pending"],
    base_timestamp=None,
    pkgs=None,
):
    stats = []
    lp_f = '{measurement},priority={priority},status={status},product={product} id="{id}",software="{software}",modifier="{modifier}" {timestamp}'.format

    base_tm = None
    if base_timestamp is not None:
        if not isinstance(base_timestamp, int) or base_timestamp < 0:
            raise ValueError
        base_tm = int(time.mktime(time.gmtime(base_timestamp))) * 1000 * 1000 * 1000

    # XXX: perhaps use a timestamp relative to the mtime of the file or git
    # commit (that would rotate out though with retention policy)
    for cve in cves:
        for pkg in cve.pkgs:
            if pkgs is not None and pkg.software not in pkgs:
                continue

            priority = cve.priority
            if pkg.software in pkg.priorities:
                priority = pkg.priorities[pkg.software]

            if pkg.status not in filter_status:
                continue

            if base_tm is None:
                timestamp = int(time.time_ns())
            else:
                timestamp = base_tm
                base_tm += 1

            stats.append(
                lp_f(
                    measurement=measurement,
                    priority=priority,
                    status=pkg.status,
                    product=pkg.product,
                    id=cve.candidate,
                    software=pkg.software,
                    modifier=pkg.modifier,
                    timestamp=timestamp,
                )
            )

    return stats


def getInfluxDBLineProtocol(cves, pkg_fn="", base_timestamp=None):
    pkgs = _readPackagesFile(pkg_fn)
    stats_open = _readStatsLineProtocol(cves, base_timestamp=base_timestamp, pkgs=pkgs)
    for s in stats_open:
        print(s)


def main():
    parser = argparse.ArgumentParser(
        prog="cve-report",
        description="Generate reports on security issues",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent(
            """\
Example usage:

# Status for open and closed issues
$ cve-report

# List open issues, by software and priority
$ cve-report --output-sw

# Todo list for software by combined priority
$ cve-report --output-todolist

# Summary report
$ cve-report --output-summary

# Summary report on packages listed in /path/to/list (one package per line)
$ cve-report --output-summary=/path/to/list
        """
        ),
    )
    parser.add_argument(
        "--output-sw",
        dest="output_sw",
        help="output software info in human-readable form",
        type=str,
        nargs="?",
        const="",
    )
    parser.add_argument(
        "--output-summary",
        dest="output_summary",
        help="output summary in human-readable form. Optional PATH to limit to package list",
        type=str,
        nargs="?",
        const="",
    )
    parser.add_argument(
        "--output-todolist",
        dest="output_todolist",
        help="output todo list in human-readable form",
        action="store_true",
    )
    parser.add_argument(
        "--output-influxdb",
        dest="output_influxdb",
        help="output InfluxDB line protocol. Optional PATH to limit to package list",
        type=str,
        nargs="?",
        const="",
    )
    parser.add_argument(
        "--output-influxdb-starttime",
        dest="output_influxdb_starttime",
        type=int,
        help="Use TIME as base start time for InfluxDB line protocol",
        default=None,
    )
    args = parser.parse_args()

    cveDirs = getConfigCveDataPaths()
    compat = getConfigCompatUbuntu()

    # First, check the syntax of our CVEs
    checkSyntax(cveDirs, compat, untriagedOk=True)

    # Gather the CVEs
    cves = []
    for cve_fn in _getCVEPaths(cveDirs):
        cves.append(CVE(fn=cve_fn, compatUbuntu=compat, untriagedOk=True))

    # send to a report
    if args.output_influxdb is not None:
        getInfluxDBLineProtocol(cves, args.output_influxdb, args.output_influxdb_starttime)
    elif args.output_todolist:
        getHumanTodo(cves)
    elif args.output_summary is not None:
        getHumanSummary(cves, args.output_summary)
    elif args.output_sw is not None:
        getHumanSoftwareInfo(cves, args.output_sw)
    else:
        getHumanReport(cves)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Aborted.")
        sys.exit(1)
