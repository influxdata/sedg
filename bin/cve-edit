#!/bin/bash
#
# Copyright (c) 2023 InfluxData
# Author: Jamie Strandboge <jamie@influxdata.com>
#
# Permission is hereby granted, free of charge, to any
# person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the
# Software without restriction, including without
# limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software
# is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice
# shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
# ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
# SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
set -e

# HELPERS

help() {
    cat <<EOM
Usage: cve-edit [ARGS] CVE...

CVE entries use:
  <product>[/<where or who>]_<software>[/<modifier>]: <status> [(<when>)]

  -p    product (<product>[/<where or who>])
  -s    software
  -m    modifier (comma-separated; use '-' to omit mod)
  -S    status (eg 'pending' or 'released')
  -w    when status applied (use with -S)

'product', 'software' and 'status' are required when specifying any of these
options.

Other options:
  -a    set Assigned-to (eg, 'First Last (handle)')
  -C    set CloseBy (eg, YYYY-MM-DD)
  -D    set Discovered-by (eg, 'dependabot' or 'First Last (handle)')
  -r    add reference URLs (comma-separated)
  -P    add patch URLs (comma-separated)
  -T    set tags (comma-separated)
  -n    dry-run

Eg:

  # modify git/<ghorg>_<repo>
  $ cve-edit -p git/<ghorg> \\
             -s foo \\
             -S pending

  # modify git/<ghorg>_<repo>/2.2 and git/<ghorg>_<repo>/2.3
  $ cve-edit -p git/<ghorg> \\
             -s foo \\
             -m 2.2,2.3 \\
             -S pending \\
             -w 0123abcd

  # modify git/<ghorg>_<repo>, git/<ghorg>_<repo>/2.2 and git/<ghorg>_<repo>/2.3
  $ cve-edit -p git/<ghorg> \\
             -s foo \\
             -m -,2.2,2.3 \\
             -S pending \\
             -w 0123abcd
EOM
}

# OSX's sed command is sufficiently different that we need gnu-sed.
# TODO: make work without gnused
sedexec="sed"
if uname -s | grep -qi "Darwin" ; then
    sedexec="gsed"

    command -v "$sedexec" >/dev/null || {
        echo "Could not find '$sedexec' in your PATH. Please 'brew install gnu-sed'"
        echo "and try again."
        exit 1
    }
fi

info() {
    if [ -z "$dry" ]; then
        echo "$*"
    fi
}

update_field() {
    key="$1"
    val="$2"
    fn="$3"
    # shellcheck disable=SC2086 # sed_args is script controlled
    "$sedexec" $sed_args "s#^$key:.*#$key: $val#" "$fn" || {
        echo "ERROR ($fn not updated for $key)"
        return 1
    }
    info "  $key updated"
}

update_references() {
    urls=$(echo "$1" | sed 's/,/\\n /g')
    fn="$2"
    # shellcheck disable=SC2086 # sed_args is script controlled
    "$sedexec" $sed_args "s#^Description:# $urls\\nDescription:#" "$fn" || {
        echo "ERROR ($fn not updated for $1)"
        return 1
    }

    info "  References updated"
}

update_patches() {
    # TODO: allow setting something other than 'vendor'
    urls=$(echo "$1" | sed 's/,/\\n vendor: /g')
    fn="$2"
    sw="$3"
    # shellcheck disable=SC2086 # sed_args is script controlled
    "$sedexec" $sed_args "s#^Patches_$sw:#Patches_$sw:\n vendor: $urls#" "$fn" || {
        echo "ERROR ($fn not updated for $1)"
        return 1
    }

    info "  Patches updated"
}

update_tags() {
    tags=$(echo "$1" | sed 's/,/ /g')
    fn="$2"
    sw="$3"
    # if the optional tags is already present, update them to the specified
    # tags
    if grep -Eq "^Tags_$sw:" "$fn" ; then
        # shellcheck disable=SC2086 # sed_args is script controlled
        "$sedexec" $sed_args "s#^Tags_$sw:.*#Tags_$sw: $tags#" "$fn" || {
            echo "ERROR ($fn not updated for $1)"
            return 1
        }
    else
        # shellcheck disable=SC2086 # sed_args is script controlled
        "$sedexec" $sed_args "s#^Patches_$sw:#Tags_$sw: $tags\nPatches_$sw:#" "$fn" || {
            echo "ERROR ($fn not updated for $1)"
            return 1
        }
    fi

    info "  Tags updated"
}

update_close() {
    close="$1"
    fn="$2"
    sw="$3"
    # if the optional CloseDate is already present, update it
    if grep -Eq "^CloseDate_$sw:" "$fn" ; then
        # shellcheck disable=SC2086 # sed_args is script controlled
        "$sedexec" $sed_args "s#^CloseDate_$sw:.*#CloseDate_$sw: $close#" "$fn" || {
            echo "ERROR ($fn not updated for $1)"
            return 1
        }
    else
        # shellcheck disable=SC2086 # sed_args is script controlled
        "$sedexec" $sed_args "s#^Patches_$sw:#CloseDate_$sw: $close\nPatches_$sw:#" "$fn" || {
            echo "ERROR ($fn not updated for $1)"
            return 1
        }
    fi

    info "  Per-package CloseDate updated"
}



validate_status() {
    case "$1" in
        needs-triage | needed | pending | released | deferred | ignored | DNE | not-affected)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# START

# software options
prod=
sw=
mods="-"
stat=
when=

# other options
assign=
disc=
dry=
refs=
patches=
tags=
close=

while getopts "hnd:p:s:m:S:w:a:C:D:r:P:T:" opt
do
    case "$opt" in
        n) dry="yes";;
        p) prod="$OPTARG";;
        s) sw="$OPTARG";;
        m) mods="$OPTARG";;
        S)
            stat="$OPTARG"
            validate_status "$stat" || {
                echo "Invalid status '$stat'" >&2
                exit 1
            }
            ;;
        w) when="$OPTARG";;
        a) assign="$OPTARG";;
        C) close="$OPTARG";;
        D) disc="$OPTARG";;
        r) refs="$OPTARG";;
        P) patches="$OPTARG";;
        T) tags="$OPTARG";;
        h) help ; exit 0;;
        ?) help;;
    esac
done
shift $((OPTIND - 1))

sed_args="-i"
if [ "$dry" = "yes" ]; then
    sed_args=""
fi

if [ -z "$1" ]; then
    echo "Missing required CVEs" >&2
    exit 1
fi

# -s must have either -P or -p and -S
if [ -n "$sw" ]; then
    if [ -z "$patches" ] && [ -z "$prod" ] && [ -z "$stat" ] && [ -z "$tags" ]; then
        echo "Missing required -P or -p and -S with -s" >&2
        exit 1
    fi
fi

# -P must have -s
if [ -n "$patches" ] && [ -z "$sw" ]; then
    echo "Missing required -s with -P" >&2
    exit 1
fi

# -T must have -s
if [ -n "$tags" ] && [ -z "$sw" ]; then
    echo "Missing required -s with -T" >&2
    exit 1
fi

# -C must have -s
if [ -n "$close" ] && [ -z "$sw" ]; then
    echo "Missing required -s with -C" >&2
    exit 1
fi

if [ -n "$prod" ] || [ -n "$stat" ]; then
    # if use -p or -S, then -p, -s and -S must all be specified
    if [ -z "$prod" ] || [ -z "$sw" ] || [ -z "$stat" ]; then
        echo "Missing required -p, -s or -S with -p and -S" >&2
        exit 1
    fi
fi

# combine status and when
if [ -n "$when" ]; then
    stat="$stat ($when)"
fi

err=
for cve in "$@"; do
    # allow using either 'CVE-...' or 'active/CVE-...'
    dir=
    if echo "$cve" | grep -q "/" ; then
        if [ ! -f "$cve" ]; then
            echo "  skipped (could not find $cve)"
            err="yes"
            continue
        fi
        dir=$(dirname "$cve")
        cve=$(basename "$cve")
    else
        for tmp in active retired ignored ; do
            if [ -f "$tmp/$cve" ]; then
                dir="$tmp"
                break
            fi
        done
        if [ -z "$dir" ]; then
            echo "  skipped (could not find $cve)"
            err="yes"
            continue
        fi
    fi

    info "$cve..."

    # software options
    # $ cve-edit -p git/<ghorg> \
    #            -s foo \
    #            -m -,2.2,2.3
    #            -S released
    #            -w 0123abcd
    #
    # updates:
    #  git/<ghorg>_<repo>/2.2: needed
    #  git/<ghorg>_<repo>/2.3: needed
    #  git/<ghorg>_<repo>: needed
    #
    # to be:
    #  git/<ghorg>_<repo>/2.2: released (0123abcd)
    #  git/<ghorg>_<repo>/2.3: released (0123abcd)
    #  git/<ghorg>_<repo>: released (0123abcd)
    if [ -n "$sw" ] && [ -n "$prod" ] && [ -n "$stat" ]; then
        for mod in ${mods//,/ }; do
            software="$sw"
            if [ -n "$mod" ] && [ "$mod" != "-" ]; then
                software="$sw/$mod"
            fi
            # shellcheck disable=SC2086 # sed_args is script controlled
            "$sedexec" $sed_args "s#^${prod}_${software}: .*#${prod}_${software}: $stat#" "$dir/$cve" || {
                echo "  ERROR ($dir/$cve not updated for '${prod}_${software}')"
                err="yes"
                continue
            }
            info "  ${prod}_${software} updated"
        done
    fi

    if [ -n "$assign" ]; then
        update_field "Assigned-to" "$assign" "$dir/$cve" || {
            err="yes"
            continue
        }
    fi

    if [ -n "$disc" ]; then
        update_field "Discovered-by" "$disc" "$dir/$cve" || {
            err="yes"
            continue
        }
    fi

    if [ -n "$refs" ]; then
        update_references "$refs" "$dir/$cve" || {
            err="yes"
            continue
        }
    fi

    if [ -n "$patches" ]; then
        update_patches "$patches" "$dir/$cve" "$sw" || {
            err="yes"
            continue
        }
    fi

    if [ -n "$tags" ]; then
        update_tags "$tags" "$dir/$cve" "$sw" || {
            err="yes"
            continue
        }
    fi

    if [ -n "$close" ]; then
        update_close "$close" "$dir/$cve" "$sw" || {
            err="yes"
            continue
        }
    fi
done

if [ -n "$err" ]; then
    exit 1
fi
exit 0
