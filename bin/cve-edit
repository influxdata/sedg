#!/bin/bash
set -e

# HELPERS

help() {
    cat <<EOM
Usage: cve-edit [ARGS] CVE...

CVE entries use:
  <product>[/<where or who>]_<software>[/<modifier>]: <status> [(<when>)]

  -p    product (<product>[/<where or who>])
  -s    software
  -m    modifier (comma-separated; use '-' to omit mod)
  -S    status (eg 'pending'or 'released')
  -w    when status applied (use with -S)

'product', 'software' and 'status' are required when specifying any of these
options.

Other options:
  -d    directory (eg 'retired'. Defaults to 'active')
  -a    set Assigned-to (eg, 'First Last (handle)')
  -D    Discovered-by (eg, 'dependabot' or 'First Last (handle)')
  -n    dry-run

Eg:

  # modify git/github_foo
  $ cve-edit -p git/github \\
             -s foo \\
             -S pending

  # modify git/github_foo/2.2 and git/github_foo/2.3
  $ cve-edit -p git/github \\
             -s foo \\
             -m 2.2,2.3 \\
             -S pending \\
             -w 0123abcd

  # modify git/github_foo, git/github_foo/2.2 and git/github_foo/2.3
  $ cve-edit -p git/github \\
             -s foo \\
             -m -,2.2,2.3 \\
             -S pending \\
             -w 0123abcd
EOM
}

# OSX's sed command is sufficiently different that we need gnu-sed.
# TODO: make work without gnused
sedexec="sed"
if uname -s | grep -qi "Darwin" ; then
    sedexec="gsed"

    command -v "$sedexec" >/dev/null || {
        echo "Could not find '$sedexec' in your PATH. Please 'brew install gnu-sed'"
        echo "and try again."
        exit 1
    }
fi

info() {
    if [ -z "$dry" ]; then
        echo "$*"
    fi
}

update_field() {
    key="$1"
    val="$2"
    fn="$3"
    # shellcheck disable=SC2086 # sed_args is script controlled
    "$sedexec" $sed_args "s#$key:.*#$key: $val#" "$fn" || {
        echo "ERROR ($fn not updated for $key)"
        return 1
    }
    info "  $key updated"
}

# START

# software options
prod=
sw=
mods="-"
stat=
when=

# other options
assign=
disc=
dry=
dir="active"

while getopts "hnd:p:s:m:S:w:a:D:" opt
do
    case "$opt" in
        n) dry="yes";;
        d) dir="$OPTARG";;
        p) prod="$OPTARG";;
        s) sw="$OPTARG";;
        m) mods="$OPTARG";;
        S) stat="$OPTARG";;
        w) when="$OPTARG";;
        a) assign="$OPTARG";;
        D) disc="$OPTARG";;
        h) help ; exit 0;;
        ?) help;;
    esac
done
shift $((OPTIND - 1))

sed_args="-i"
if [ "$dry" = "yes" ]; then
    sed_args=""
fi

if [ -z "$1" ]; then
    echo "Missing required CVEs" >&2
    exit 1
elif [ -n "$prod" ] || [ -n "$sw" ] || [ -n "$stat" ]; then
    # if use -p, -s or -S, they must all be specified
    if [ -z "$prod" ] || [ -z "$sw" ] || [ -z "$stat" ]; then
        echo "Missing required -p, -s or -S" >&2
        exit 1
    fi
fi

if [ "$dir" != "active" ] && [ "$dir" != "retired" ] && [ "$dir" != "ignored" ]; then
    echo "Invalid directory '$dir' (use one of: active, retired, ignored" >&2
    exit 1
fi

# combine status and when
if [ -n "$when" ]; then
    stat="$stat ($when)"
fi

err=
for cve in "$@"; do
    info "$cve... "
    if [ ! -f "$dir/$cve" ]; then
        echo "  skipped ($dir/$cve does not exist)"
        err="yes"
        continue
    fi

    # software options
    # $ cve-edit -p git/github \
    #            -s foo \
    #            -m -,2.2,2.3
    #            -S released
    #            -w 0123abcd
    #
    # updates:
    #  git/github_foo/2.2: needed
    #  git/github_foo/2.3: needed
    #  git/github_foo: needed
    #
    # to be:
    #  git/github_foo/2.2: released (0123abcd)
    #  git/github_foo/2.3: released (0123abcd)
    #  git/github_foo: released (0123abcd)
    for mod in ${mods//,/ }; do
        software="$sw"
        if [ -n "$mod" ] && [ "$mod" != "-" ]; then
            software="$sw/$mod"
        fi
        # shellcheck disable=SC2086 # sed_args is script controlled
        "$sedexec" $sed_args "s#${prod}_${software}: .*#${prod}_${software}: $stat#" "$dir/$cve" || {
            echo "  ERROR ($dir/$cve not updated for '${prod}_${software}')"
            err="yes"
            continue
        }
        info "  ${prod}_${software} updated"
    done

    if [ -n "$assign" ]; then
        update_field "Assigned-to" "$assign" "$dir/$cve" || {
            err="yes"
            continue
        }
    fi

    if [ -n "$disc" ]; then
        update_field "Discovered-by" "$disc" "$dir/$cve" || {
            err="yes"
            continue
        }
    fi
done

if [ -n "$err" ]; then
    exit 1
fi
exit 0
